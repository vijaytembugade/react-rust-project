import React from "react";
import MarkdownPreview from "@uiw/react-markdown-preview";

const text =
  "```glsl\n#version 330 core\n\n// Input vertex attributes (usually from the vertex shader)\nin vec3 vertexPosition;\n\n// Output color (to fragment shader)\nout vec4 fragmentColor;\n\nvoid main() {\n  // Simple black color\n  fragmentColor = vec4(0.0, 0.0, 0.0, 1.0); // Black, fully opaque\n\n  // Alternatively, you could make it transparent, but it would still be a black box\n  // fragmentColor = vec4(0.0, 0.0, 0.0, 0.5); // Black, semi-transparent\n}\n```\n\n**Explanation:**\n\n*   **`#version 330 core`**:  Specifies the OpenGL Shading Language (GLSL) version.  Use this for modern OpenGL contexts.\n*   **`in vec3 vertexPosition;`**:  Declares an input variable called `vertexPosition`.  This is where the vertex position data, as calculated by the vertex shader, is received.  The `vec3` means it's a 3D vector (x, y, z).  This is a standard input for a geometry shader.\n*   **`out vec4 fragmentColor;`**:  Declares an output variable called `fragmentColor`. This is what the fragment shader outputs, representing the color of the fragment (pixel) being drawn.  The `vec4` means it's a 4D vector (red, green, blue, alpha).\n*   **`void main() { ... }`**: The `main` function is the entry point of the fragment shader.  The code inside it will be executed for every fragment.\n*   **`fragmentColor = vec4(0.0, 0.0, 0.0, 1.0);`**:  This is the core of the shader.  It sets the `fragmentColor` to black.\n    *   `0.0, 0.0, 0.0`:  Represents the red, green, and blue components, respectively.  A value of `0.0` for each of these means no color, resulting in black.\n    *   `1.0`: Represents the alpha (transparency) component.  A value of `1.0` means fully opaque (completely solid).  A value of `0.0` would mean fully transparent.  Values in between provide partial transparency (blending with what's behind).\n\n**How to use this shader in a graphics application:**\n\n1.  **Compile the Shader:**  Use a graphics library (e.g., OpenGL, Vulkan, DirectX) to load this code as a fragment shader and compile it.  You'll also need a vertex shader (usually a simple pass-through shader that transforms the vertices into clip space).\n2.  **Create a Shader Program:** Link the compiled vertex and fragment shaders into a shader program.\n3.  **Set Up Geometry:** Create the geometry for your \"black box.\"  This usually involves defining vertices and connecting them to form triangles, quadrilaterals, or other shapes. A simple cube is often used.  You need to provide the positions of the vertices in 3D space.\n4.  **Bind the Shader Program:** Before drawing your black box, bind the compiled shader program to the rendering context (OpenGL, etc.). This tells the graphics card to use your shader for the upcoming draw calls.\n5.  **Provide Vertex Data:** Supply the vertex data (vertex positions) to the graphics card using the shader program.\n6.  **Draw the Geometry:** Call a draw function (e.g., `glDrawArrays`, `glDrawElements`) to render the geometry.\n\n**Vertex Shader (Example for a simple pass-through vertex shader):**\n\n```glsl\n#version 330 core\n\nlayout (location = 0) in vec3 inVertexPosition;\n\nuniform mat4 modelViewProjectionMatrix; // Usually set by the application\n\nout vec3 vertexPosition;\n\nvoid main() {\n  // Pass the vertex position to the fragment shader\n  vertexPosition = inVertexPosition;\n\n  gl_Position = modelViewProjectionMatrix * vec4(inVertexPosition, 1.0);\n}\n```\n\n*   This vertex shader takes vertex positions as input (`inVertexPosition`).\n*   It transforms the positions using a `modelViewProjectionMatrix` (which you would typically set in your C++ or Python code). This matrix converts the model's local coordinates to clip coordinates, which are needed for rendering.\n*   It passes the original vertex position `vertexPosition` to the fragment shader.\n\n**Key points:**\n\n*   **Vertex Shader and Fragment Shader Work Together:**  The vertex shader calculates the position of each vertex, and the fragment shader determines the color of each pixel.\n*   **Matrix Transformations (Vertex Shader):** The vertex shader often performs transformations (scaling, rotation, translation, projection) on the vertex positions. The `modelViewProjectionMatrix` is crucial for this.\n*   **Alpha:** The `fragmentColor`'s alpha component controls transparency.\n*   **GLSL Libraries:** You'll need an OpenGL, Vulkan, or DirectX (or other graphics API) library to manage the shaders, vertex data, and rendering pipeline in your application.\n*   **Error Checking:** Always check for shader compilation and linking errors in your graphics code to debug issues.\n\nThis gives you a solid foundation for creating a black box. Remember to adapt the vertex shader and other application code to fit your rendering environment.";

const ShaderViewer = () => {
  return (
    <div>
      <MarkdownPreview source={text} style={{ padding: 16 }} />
    </div>
  );
};

export default ShaderViewer;
